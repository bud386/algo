- [ ]  CPU
- [ ]  context switching
- [ ]  scheduling
- [ ]  동기화(임계구역, 세마포어 뮤텍스)



# CPU

중앙처리장치(CPU: Central Processing Unit)는 사람의 두뇌와 같이 컴퓨터 시스템에 부착된 모든 장치의 동작을 제어하고 명령을 실행하는 장치입니다. 중앙 처리장치는 제어장치, 연산장치, 레지스터 그리고 이들을 연결하여 데이터를 전달하는 버스로 구성되어 있습니다.

**구성요소**

**제어장치**

제어장치(Control Unit)는 컴퓨터에 있는 모든 장치들의 동작을 지시하고 제어하는 장치입니다. 제어장치는 명령 레지스터에서 읽어들인 명령어를 해독하여 해당하는 장치에게 제어 신호를 보내 정확하게 수행하도록 지시합니다.

제어장치 구성요소

- 명령 레지스터 : 현재 실행중인 명령어의 내용을 기억하고 있습니다.
- 명령 해독기(Decoder) : 명령 레지스터에 있는 명령어를 해독하는 회로입니다.
- 제어신호 발생기, 부호기(Encoder) : 해독된 명령에 따라 각 장치로 보낼 제어 신호를 생성하는 회로입니다.
- 제어 주소 레지스터(CAR) : 다음에 실행할 마이크로명령어의 주소를 저장하는 레지스터로, Mapping의 결과값, 주소 필드, 서브루틴 레지스터의 내용들이 적재되어 있습니다.
- 제어 버퍼 레지스터(CBR) : 제어 기억장치로부터 읽혀진 마이크로명령어 비트들을 일시적으로 저장하는 레지스터입니다.
- 제어 기억장치 : 마이크로 명령어들로 이루어진 마이크로명령어 비트들을 일시적으로 저장하는 레지스터입니다.
- 순서 제어 모듈 : 마이크로명령어의 실행 순서를 결정하는 회로들의 집합입니다.
- 순차카운터(Sequence counter) : 디코더에 의해 선택된 번호에 해당하는 타이밍신호를 생성합니다.

**연산장치**

연산장치(ALU, Artihmetic)는 제어장치의 명령에 따라 실제로 연산을 수행하는 장치입니다. 연산장치가 수행하는 연산에는 산술연산, 논리연산, 관계연산, 이동등이 있으며 연산장치는 가산기, 누산기, 보수기, 데이터 레지스터, 오버플로 검출기, 시프트레지스터등으로 구성되어 있습니다.

**레지스터**

레지스터(Register)는 CPU 내부에서 처리할 명령어나 연산의 중간 결과값 등을 일시적으로 기억하는 임시 기억장소입니다.

- 레지스터는 플립플롭이나 래치들을 병렬로 연결하여 구성합니다.
- 레지스터는 메모리 중에서 속도가 가장 빠릅니다.
- 레지스터의 크기는 워드를 구성하는 비트 개수만큼의 플립플롭을 구성되며, 여러개의 플립플롭은 공통 클록의 입력에 의해 동시에 여러 비트의 자료가 저장됩니다. 
- 레지스터를 구성하는 플립플롭은 저장하는 값을 임의로 설정하기 위해 별도의 입력 단자를 추가할 수 있으며, 저장값을 0으로 하는 것을 설정해제(CLR)이라 합니다.

**버스**

버스는 CPU, 메모리, I/O 장치 등과 상호 필요한 정보를 교환하기 위해 연결된 공동의 전송선입니다.

컴퓨터 내부 회로에서 버스선(Bus Lines)을 사용하는 목적은 결선수를 줄이기 위해서입니다.

메모리나 입 출력 장치가 제대로 동작하려면 버스를 통해 전달되는 제어 신호 어드레스 신호 및 데이터 신호의 상호 시간적 관계가 잘 유지되어야 합니다.



# 스케줄링

프로세스가 생성되어 실행될때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업을 의미

공정한 스케줄링, 처리량의 극대화, 응답시간 최소화, 균형있는자원 활용, 반환시간 예측 등이 목표

- 목표
  1. `Batch System`: 가능하면 많은 일을 수행. 시간(time) 보단 처리량(throughout)이 중요
  2. `Interactive System`: 빠른 응답 시간. 적은 대기 시간.
  3. `Real-time System`: 기한(deadline) 맞추기.

**종류**

1. 비선점 스케줄링

- 비선점 (nonpreemptive) : 프로세스 종료 or I/O 등의 이벤트가 있을 때까지 실행 보장 (처리시간 예측 어려움

  1. FCFS (First Come First Served)
     - 큐에 도착한 순서대로 CPU 할당
     - 실행 시간이 짧은 게 뒤로 가면 평균 대기 시간이 길어짐
  2. SJF (Shortest Job First)
     - 수행시간이 가장 짧다고 판단되는 작업을 먼저 수행
     - FCFS 보다 평균 대기 시간 감소, 짧은 작업에 유리

  ___

  

2. 선점 스케줄링

- 선점 (preemptive) : OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수하는 경우

  1. Priority Scheduling
     - 정적/동적으로 우선순위를 부여하여 우선순위가 높은 순서대로 처리
     - 우선 순위가 낮은 프로세스가 무한정 기다리는 Starvation 이 생길 수 있음
     - Aging 방법으로 Starvation 문제 해결 가능
  2. Round Robin
     - FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 Time Quantum 만큼 CPU를 할달 받음
       - `Time Quantum` or `Time Slice` : 실행의 최소 단위 시간
     - 할당 시간(`Time Quantum`)이 크면 FCFS와 같게 되고, 작으면 문맥 교환 (Context Switching) 잦아져서 오버헤드 증가
  3. Multilevel-Queue (다단계 큐)
     - 작업들을 여러 종류의 그룹으로 나누어 여러 개의 큐를 이용하는 기법
     - 우선순위가 낮은 큐들이 실행 못하는 걸 방지하고자 각 큐마다 다른 `Time Quantum`을 설정 해주는 방식 사용
     - 우선순위가 높은 큐는 작은 `Time Quantum` 할당. 우선순위가 낮은 큐는 큰 `Time Quantum` 할당.
  4. Multilevel-Feedback-Queue (다단계 피드백 큐)
  5. 다단계 큐에서 자신의 Time Quantum 을 다 채운 프로세스는 밑으로 내려가고 자신의 Time Quantum을 다 채우지 못한 프로세스는 원래 큐 그대로
     - Time Quantum을 다 채운 프로세스는 CPU burst 프로세스로 판단하기 때문
     - 짧은 작업에 유리, 입출력 위주(Interrupt가 잦은) 작업에 우선권을 줌
     - 처리 시간이 짧은 프로세스를 먼저 처리하기 때문에 Turnaround 평균 시간을 줄여줌

  

  **CPU 스케줄링 척도**

  1. Response Time
     - 작업이 처음 실행되기까지 걸린 시간
  2. Turnaround Time
     - 실행 시간과 대기 시간을 모두 합한 시간으로 작업이 완료될 때 까지 걸린 시간

## 문맥 교환(context switching)

컴퓨터에서 동시에 처리할 수 있는 최대 작업 수는 CPU의 코어(core) 수와 같습니다.

만약 CPU의 코어 수보다 더 많은 스레드가 실행되면, 각 코어가 정해진 시간 동안 여러 작업을 번갈아가며 수행하게 됩니다.

이때 각 스레드가 서로 교체될 때 스레드 간의 문맥 교환(context switching)이라는 것이 발생합니다.



문맥 교환이란 현재까지의 작업 상태나 다음 작업에 필요한 각종 데이터를 저장하고 읽어오는 작업을 가리킵니다.

이러한 문맥 교환에 걸리는 시간이 커지면 커질수록, 멀티 스레딩의 효율은 저하됩니다.

오히려 많은 양의 단순한 계산은 싱글 스레드로 동작하는 것이 더 효율적일 수 있습니다.

따라서 많은 수의 스레드를 실행하는 것이 언제나 좋은 성능을 보이는 것은 아니라는 점을 유의해야 합니다.

___

멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)를 **교체하는 작업**을 Context Switch(Context Switching)라고 한다.

> **Context는 무엇인가?**

사용자와 다른 사용자, 사용자와 시스템 또는 디바이스간의 상호작용에 영향을 미치는 사람, 장소, 개체등의 현재 상황(상태)을 규정하는 정보들을 말한다.

Context는 CPU가 해당 프로세스를 실행하기 위한 해당 프로세스의 정보들이다.

이 **Context는 프로세스의 PCB(Process Control Block)에 저장**된다.

그래서 Context Switching 때 PCB의 정보를 읽어(적재) CPU가 전에 프로세스가 일을 하던거에 이어서 수행이 가능한 것이다.

참고로 Context Switching 때 해당 CPU는 아무런 일을 하지 못한다. 따라서 컨텍스트 스위칭이 잦아지면 오히려 오버헤드가 발생해 효율(성능)이 떨어진다.



> **Context Switching - 인터럽트(Interrupt)**

인터럽트는 CPU가 프로그램을 실행하고 있을 때 실행중인 프로그램 밖에서 예외 상황이 발생하여 처리가 필요한 경우 CPU에게 알려 예외 상황을 처리할 수 있도록 하는 것을 말한다.

어떤 인터럽트 요청이 와야 Context Switching이 일어날까?

\1. I/O request (입출력 요청할 때)

\2. time slice expired (CPU 사용시간이 만료 되었을 때)

\3. fork a child (자식 프로세스를 만들 때)

\4. wait for an interrupt (인터럽트 처리를 기다릴 때)

___

- 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정을 말합니다.

**진행과정**

- Task의 대부분 정보는 Register에 저장되고 PCB(Process Control Block)로 관리되고 있습니다.
- 현재 실행하고 있는 Task의 PCB 정보를 저장하게 됩니다. (Process Stack, Ready Queue)
- 다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행을 할 수 있습니다.

**Context Switching Cost**

- Context Switching이 발생하게 되면 많은 Cost가 소요됩니다.
  - Cache 초기화
  - Memory Mapping 초기화
  - Kernel은 항상 실행되어야 합니다. (메모리의 접근을 위해서..)

**Process vs Thread**

- Context Switching 비용은 Process가 Thread보다 많이 듭니다.
  - Thread는 Stack 영역을 제외한 모든 메모리를 공유하기 때문에
  - Context Switching 발생시 Stack 영역만 변경을 진행하면 됩니다.

___



# **세마포어와 뮤텍스**

공유된 자원에 여러 프로세스가 동시에 접근하면서 문제가 발생할 수 있다. 이때 공유된 자원의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 둬야 한다.

이를 위해 나온 것이 바로 **'세마포어'**

**세마포어** : 멀티프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법



#### 임계 구역(Critical Section)

여러 프로세스가 데이터를 공유하며 수행될 때, **각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분**

공유 데이터를 여러 프로세스가 동시에 접근할 때 잘못된 결과를 만들 수 있기 때문에, 한 프로세스가 임계 구역을 수행할 때는 다른 프로세스가 접근하지 못하도록 해야 한다.



### 세마포어 P, V 연산

P : 임계 구역 들어가기 전에 수행 ( 프로세스 진입 여부를 자원의 개수(S)를 통해 결정)

V : 임계 구역에서 나올 때 수행 ( 자원 반납 알림, 대기 중인 프로세스를 깨우는 신호 )





**뮤텍스** : 임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술

> 상호 배제(**Mut**ual **Ex**clusion)의 약자임

해당 접근을 조율하기 위해 lock과 unlock을 사용한다.

- lock : 현재 임계 구역에 들어갈 권한을 얻어옴 ( 만약 다른 프로세스/스레드가 임계 구역 수행 중이면 종료할 때까지 대기 )
- unlock : 현재 임계 구역을 모두 사용했음을 알림. ( 대기 중인 다른 프로세스/스레드가 임계 구역에 진입할 수 있음 )



뮤텍스는 상태가 0, 1로 **이진 세마포어**로 부르기도 함

___

> 프로세스 동기화 

**프로세스는 서로 메세지를 보내고 프로세스 내부에서는 쓰레드끼리 자원을 공유하면서 '동기화'에 대한 문제가 항상 발생할 수 있다.** 즉 공유된 자원에 여러 프로세스, 여러 쓰레드가 동시에 접근하면서 문제가 발생하게 된다. 유저 동기화 방법과 커널 동기화 방법이 있는데 **유저 동기화는 Critical Section(임계영역)** , **커널 동기화는 Mutex , Semaphore** 가 있다.

> Critical Section(임계구역)

OS에서 임계구역은 상당히 중요한 부분이다. **멀티 프로세스 환경에서 둘 이상의 프로세스가 동시에 접근해서는 안되는 공유 자원의 코드 영역이다.** 임계구역은 시간이 지나면 종료되며, 어떤 프로세스가 임계구역에 접근하기 위해서는 지정된 시간만큼 대기해야 한다. 이때 쓰레드나 프로세스가 배타적인 사용권을 보장받기 위해서 세마포어 같은 동기화 메커니즘이 사용된다. 

하나의 쓰레드가 임계구역에 접근하기 위해서는 요청->필요시 대기->임계구역 처리->빠져나간다 의 순서로 이루어진다.

**임계구역 문제를 해결하기 위한 3가지 조건**

임계구역에서 발생하는 문제들은 3가지 조건을 충족시키면 해결할 수 있다.

1.Mutual Exclusion(상호배제) : 하나의 프로세스가 임계구역에 들어가 있으면 다른 프로세스는 들어갈 수 없다.

2.Progress(진행) : 임계구역에 들어간 프로세스가 없다면, 어느 프로세스가 들어갈 것인지 적절히 선택해줘야 한다.

3.Bounded Waiting(한정 대기) : 기아상태를 방지하기 위해, 한 번 들어갔다 나온 프로세스는 다음에 들어갈 때 제한을 준다. 

> Mutex(상호배제)

MUTual EXclusion에서 부르기 좋게 따온 이름으로써 '상호배제' 의미를 가진다. 커널 모드 동기화 객체이다. **동시 프로그래밍 환경(멀티 프로세스 및 멀티 쓰레드 같은)에서 공유 불가능한 자원의 동시 사용을 막기 위해 사용되는 알고리즘**으로, 임계구역에서 구현된다. 단일 프로세서 시스템에서 상호배제를 구현하는 간단한 방법은 인터럽트를 억제해서 공유데이터 손상을 막는 것이다. 일종의 Locking 메커니즘이라 할 수 있다. lock을 가진 쓰레드만이 임계구역에 접근할 수 있는것이다. 임계구역에서 작업이 끝난 쓰레드는 Unlock하여 lock을 반환한다. 

> Semaphore(세마포어)

**두 개의 원자적 함수로 조작되는 정적 변수로써, 멀티 프로그래밍 환경에서 공유 자원(임계구역)에 대한 접근을 제한하는 방법으로 사용된다**. 이는 **철학자들의 만찬 문제**의 고전적인 해결책이지만, 모든 교착 상태를 해결하지는 못한다.

**구성**

**세마포어 S는 정수값을 가지는 변수이며 다음과 같은 P와 V라는 명령어에 의해서만 접근할 수 있다.** (P와 V는 try와 increment를 뜻하는 네델란드어에서 따왔다.)

P는 임계구역에 들어가기 전에 수행되고(try) , V는 임계구역에서 나올 때 수행된다. (increase) 이 때 변수값을 수정하는 연산은 모두 '원자성'을 만족해야 한다. 다시 말해, 한 프로세스나 쓰레드에서 S값을 변경하는 동안에는 다른 프로세스나 쓰레드가 **동시에 접근해서 변경할 수 없다.** 

값이 0보다 크면 접근을 허용하되 1을 감소하고, 값이 0이면 접근을 block시킨다. 반대로 작업이 끝나고 프로세스나 쓰레드가 나갈때는 값을 1로 증가시켜 다른 프로세스나 스레드가 접근할 수 있도록 한다. 여기서 접근되는 자원은 임계구역이므로 시스템 퍼포먼스에 많은 영향을 끼친다.



> 뮤텍스와 세마포어의 차이



우리(프로세스)가 방(자원)에 들어가려고 할 때, 뮤텍스는 방에 들어가기 위한 열쇠의 개수이며, 세마포어는 빈 방의 열쇠의 개수이다.

즉 뮤텍스는 한 사람이 빈 방에 대한 열쇠를 가지고 있어서 방에 들어간다면, 그 사람이 나와야만 다른 사람이 열쇠를 건네받아 방을 들어갈 수 있다.

반면 세마포어는 방이 네개면 열쇠도 네개일 것이고 한 사람이 들어갈 때마다 들어갈 수 있는 방은 하나씩 줄어들어 0개가 되면 빈 방이 나올때 까지 대기해야 하는 상황이다. 아무나 먼저 나와야만 방과 열쇠를 한개씩 얻어서 들어갈 수 있다.



1.세마포어는 자원의 상태를 나타내는 일종의 '변수'로써 소유 개념이 아니지만, 뮤텍스는 자원을 점유한 프로세스나 쓰레드가 잠시 소유하였다가 작업이 끝나면 반환하는 개념이다.

2.뮤텍스는 소유하고 있는 쓰레드가 뮤텍스 자원을 해제할 수 있지만 세마포어는 소유하지 않는 쓰레드여도 해제할 수 있다.(?)

3.가장 큰 차이점은 뮤텍스가 동기화 대상이 자원의 하나라면, 세마포어는 하나 이상일 때 사용된다.

세마포어는 여러개의 프로세스 사용가능, 뮤텍스는 하나의 스레드만 사용가능