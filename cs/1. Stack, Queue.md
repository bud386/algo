# 1. Stack, Queue

스택은 나중에 넣은 데이터가 먼저 나오는 형태

큐는 먼저 넣은 데이터가 먼저 나오는 형태

## 1. Stack

- 객체들의 집합소로써, 데이터를 기록하는 구조이다.

- 차곡차곡 쌓아 올린 형태의 자료구조(**같은 구조와 크기의 자료**를 **정해진 방향으로만** 쌓을수 있다.)
- top으로 정한 곳을 통해서만 접근할 수 있으며, top에는 가장 위에 있는 자료는 가장 최근에 들어온 자료를 가리키고 있다.

- 접근 방법은 **LIFO(Last Input First Out)** 라고 부르며, 마지막에 넣은 요소가 먼저 나온다는 의미

- 비어있는 스택에서 원소를 추출하려고 할 때 stack underflow라고 하며, 스택이 넘치는 경우 stack overflow라고 한다.

#### 스택의 활용 예시

스택의 특징인 후입선출(LIFO)을 활용하여 여러 분야에서 활용 가능하다.

- 웹 브라우저 방문기록 (뒤로 가기) : 가장 나중에 열린 페이지부터 다시 보여준다.
- 역순 문자열 만들기 : 가장 나중에 입력된 문자부터 출력한다.
- 실행 취소 (undo) : 가장 나중에 실행된 것부터 실행을 취소한다.
- 후위 표기법 계산
- 수식의 괄호 검사 (연산자 우선순위 표현을 위한 괄호 검사)



![img](https://blog.kakaocdn.net/dn/chSIl3/btqx60O47Om/g4dMrq8KSyobAkspK6JLJ0/img.png)



## 2. Queue

- 큐는스택의 반대 개념을 갖는다.

- 접근 방법은 **FIFO (First Input First Out)** 라고 불리며, 먼저 들어간 데이터가 먼저 나오는 구조이다.

- 삭제연산만 수행되는 곳을 프론트(front), 삽입연산만 이루어지는 곳을 리어(rear) 라고 부른다.

  출처: https://devuna.tistory.com/22 [튜나 개발일기]

![img](https://blog.kakaocdn.net/dn/zHUPa/btqx60VRYdp/QPMF62rkahGSL5tzl5TYbK/img.png)

> 우리가 흔히 볼 수 있는 접근하는 순서대로 처리하는 형태
>
> 주로 순서를 보장하기 위한 처리가 필요할 때 사용된다.



#### 큐의 활용예시

큐는 주로 데이터가 입력된 시간 순서대로 처리해야 할 필요가 있는 상황에 이용한다.

- 우선순위가 같은 작업 예약 (프린터의 인쇄 대기열)
- 은행 업무
- 콜센터 고객 대기시간
- 프로세스 관리
- 너비 우선 탐색(BFS, Breadth-First Search) 구현
- 캐시(Cache) 구현



___







# 2. 그래프와 트리의 차이

1. 그래프

정점(노드)와 정점을 연결하는 간선으로 구성된 자료구조.  

계층이 없는 네트워크 모델이며, 싸이클(순환)이 존재할 수도, 존재하지 않을 수도 있다.

연결되어 있는 객체간의 관계를 표현할 수 있느 자료구조.

2. 트리

그래프이 종류 중 하나로, 노드와 간선으로 이루어진 비선형 자료구조입니다.   

루트 노트가 존재하고, 부모-자식 관계로 이루어진 계층적인 모델입니다.   

노드와 노드는 단 하나의 간선으로 연결되어 있으며, 싸이클이 존재하지 않습니다.

![img](../../img.png)



___







# 3. DFS와 BFS

DFS는 스택을 사용하고, BFS는 큐를 사용한다.

## 깊이 우선 탐색 (DFS, Depth-First Search)

### 개념

- 최대한 깊이 내려간 뒤, 더이상 깊이 갈 곳이 없을 경우 옆으로 이동.
- 현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색

- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 **해당 분기를 완벽하게 탐색**하는 방식.
- 한 루트로 탐색하다가 특정 상황에서 최대한 깊숙히 들어가서 확인한뒤 다시 돌아가 다른 루트로 탐색하는 방식.

- 스택 사용해서 구현

### 사용

- 모든 노드를 방문하고자 하는 경우
- 경로의 특징을 저장해줘야 할때

## 너비 우선 탐색 (BFS, Breadth-First Search)

### 개념

- 최대한 넓게 이동한 다음, 더 이상 갈 수 없을 때 아래로 이동
- 현재 정점에 연결된 가까운 점들부터 탐색

- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 **인접한 노드를 먼저** **탐색**하는 방법으로,시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법입니다.

- 큐를 이용해서 구현

### 사용

- 주로 두 노드 사이의 최단 거리를 찾고 싶을때 사용
- 모든 노드를 방문하고자 하는 경우

___







# 4. 정렬 알고리즘의 Best, Worst, Average

https://coding-factory.tistory.com/615 

1. 선택 정렬

   - 선택정렬은 앞에서부터 차례대로 정렬하는 방법
   - 먼저 주어진 리스트 중에 최소값을 찾고 그 값을 맨 앞에 위치한 값과 교체하는 방식으로 진행하는 정렬 방법.
   - 내림차순으로 정렬되어 있는 자료를 오름차순으로 재정렬할 때 최적의 효율.
   -  이미 정렬된 상태에서 소수의 자료가 추가됨으로 재정렬하게 되는 때에는 최악의 처리 속도.
   - 정렬을 위한 비교 횟수는 많으나 교환 횟수는 상당히 적다는 것이 장점
   -  n개의 원소에 대하여 n개의 메모리를 사용 -> 데이터를 하나씩 정밀 비교가 가능

   

2. 버블 정렬

   - 버블정렬은 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 끝부터 정렬하는 방식
   - n개의 원소에 대하여 n개의 메모리를 사용 -> 데이터를 하나씩 정밀 비교가 가능
   - 정밀하게 비교가 가능하나 비교횟수가 많아지므로 성능면에서는 좋은 방법이 아니다

   

3. 삽입 정렬

   - 삽입 정렬은 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 정렬 방법.

   - 정렬된 값은 한번도 교환이 일어나지 않고 N-1의 비교만 일어난다.

   - 데이터의 상태 및 데이터의 크기에 따라서 성능의 편차가 굉장히 심한 정렬법

   -  버블정렬은 비교대상의 메모리 값이 정렬되어 있음에도 불구하고 비교연산을 하는 부분 보완

     

4. 병합 정렬

   - 작은 단위로 잘게 쪼개어 작은 단위부터 정렬해서 정렬된 단위들을 계속 병합해가면서 정렬하는 방식.

   - 소팅과 비슷하게 원본 배열을 반씩 분할해가면서 정렬하는 정렬법으로써 분할 하는 과정에서 logN 만큼의 시간이 걸린다. 즉, 최종적으로 보게되면 NlogN 이 된다.

   - 퀵소팅과 달리, Pivot을 설정하거나 그런 과정 없이 무조건 절반으로 분할하기 때문에 Pivot에 따라서 성능이 안좋아지거나 하는 경우가 없다. 따라서 항상 O(NlogN) 이라는 시간복잡도

   - 큰 결점이 있다면 공간이 많이 필요하다

   - 데이터가 최악인 것만 본다면 퀵보다는 병합정렬이 훨씬 빠르기때문에 병합정렬을 사용하는것이 많지만, 추가적인 메모리를 할당할 수 없다면 병합정렬은 사용할 수 없기 때문에 퀵을 사용해야 하는 것이다.

     

5. 퀵 정렬

   - 연속적인 분할에 의한 정렬방식입니다. 처음 하나의 축(Pivot)을 먼저 정하여 이 축의 값보다 작은 값은 왼쪽에 큰 값은 오른쪽으로 위치시킨뒤 왼쪽과 오른쪽의 수 들은 다시 각각의 축으로 나누어져 축값이 1이 될 때까지 정렬.

   - 준값(Pivot)에 따라서 시간복잡도가 크게 달라진다. Pivot이 적당하게 이상적인 값을 선택했다면 NlogN의 시간복잡도를 갖지만, 최악으로 Pivot을 선택할 경우 N^2이라는 시간복잡도를 갖게 된다.

     

6. 힙 정렬

   - 힙 정렬은 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법
   - 처음에는 나무 아래에서 위로 각 원소들을 최대값 힙 조건에 맞게 정리한 뒤, 나무 뿌리에 있는 자료를 차례차례 나무 뒤로 옮기면서 힙을 정렬된 배열로 바꿉니다. 뿌리에는 힙 나무 맨 뒤에 있던 원소가 왔다가, 다시 힙 조건에 맞는 위치로 내려갑니다.

   

7. 쉘 정렬

   - 삽입정렬의 단점을 보완해서 만든 정렬법

   

8. 기수 정렬

   - 데이터의 비교를 통한 정렬이 아닌 분산 정렬을 이용한 정렬 방법이며 자릿수가 있는 데이터(정수, 문자열 등)에만 사용 가능합니다. 각 자리수를 기준으로 점차 정렬을 진행합니다.

   - 버킷' 이라는 추가적인 메모리가 할당되어야 한다. 즉, 메모리가 엄청나게 여유롭다면 상관이 없겠지만 메모리가 생각보다

   

9. 카운팅 정렬

   - 요소를 인덱스로 하는 배열에 요소들의 등장 회수를 세어서 저장한 후 정렬에 사용한다.

   - 이 정렬법도 비교를 하지 않고 정렬하는 법으로 O(N) 이라는 시간복잡도를 갖게 된다.

   - 숫자 갯수를 저장해야 될 별도의 공간, 또 결과를 저장할 별도의 공간 등 추가적인 메모리가 필요하다.

     예를 들면 다음과 같은 경우이다.

        [ 1, 2, 3, 4, 5, 99999999999 ] 이 경우에는 99999999999 때문에 숫자의 갯수를 저장해야 될 배열의 크기가

        최소 [ 99999999999 ] 보다는 커야 하고, 결과적으로 안 쓰는 낭비되는 인덱스들이 많이 발생하게 된다.

     

     

___

![image-20210704014721658](C:\Users\mph\AppData\Roaming\Typora\typora-user-images\image-20210704014721658.png)

___

![image-20210704014742344](C:\Users\mph\AppData\Roaming\Typora\typora-user-images\image-20210704014742344.png)





![img](../../img.png)

___







# 5. 이진트리, 이진검색트리, 완전이진트리

### 이진 트리 (binary tree)

각 노드가 최대 두 개의 자식을 갖는 트리입니다.
모든 트리가 binary tree는 아닙니다.



### 이진 검색 트리 (binary search tree)

모든 노드가 특정 순서를 따르는 속성이 있는 이진 트리입니다.

특정 순서란?

> ex) 모든 왼쪽 자식들은 root(혹은 부모)보다 작은 값이며, 모든 오른쪽 자식들은 root(혹은 부모)보다 큰 값입니다.



### 완전 이진 트리 (complete Binary Tree)

트리의 모든 높이에서 노드가 꽉 차 있는 모든 트리를 말합니다. 마지막 노드를 제외한 모든 노드들이 두 개씩 전부 채워져 있어야 하며, 만약 하나가 비워져 있다고 하더라도 오른쪽이 비워져 있어야 합니다.



### 정 이진 트리 (full binary tree)

모든 노드가 0개 또는 2개의 자식 노드를 가지고 있어야 합니다. 1개를 가지고 있는 것은 정 이진 트리가 아닙니다.



### 포화 이진 트리 (Perfect Binary tree)

완전 이진 트리와 정 이진 트리를 합친 건데요, 영어를 그대로 직역한 것처럼.. Perfect, 꽉 차 있어야 되는 트리입니다. 마지막을 제외한 모든 노드가 두 개의 자식 노드를 가져야 합니다.